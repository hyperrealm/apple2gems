PLOT        := $F800 ; Plot lo-res point at col Y, row A.
PLOT1       := $F80E ; Plot lo-res point at col Y, row GBAS.
HLINE       := $F819 ; Plot lo-res horizontal line at row A, cols Y - H2.
VLINE       := $F828 ; Plot lo-res vertical line at col Y, rows A - V2.
CLRSCR      := $F832 ; Clear the entire lo-res screen.
CLRTOP      := $F836 ; Clear the top 40 rows of the lo-res screen.
CLRSC2      := $F838 ; Clear the lo-res screen from the top to row Y.
CLRSC3      := $F83C ; Clear the lo-res screen from top left to row V2, col Y.
GBASCALC    := $F847 ; Calculate base address for lo-res point where A contains row / 2.
NXTCOL      := $F85F ; Add 3 to current lo-res color that was set by SETCOL.
SETCOL      := $F864 ; Set the lo-res color to A.
SCRN        := $F871 ; Return in A the color code for lo-res point at row A, col Y.
INSDS2      := $F88E ; Compute length of 65(C)02 instruction in A. Stores length - 1 at LENGTH.
GET816LEN   := $F890 ; Compute length of 65C812 instruction in A. Stores length - 1 at LENGTH. (IIGS)
INSTDSP     := $F8D0 ; Display disassembled instruction at address in PCL/H.
PRNTYX      := $F940 ; Print contents of Y and X in hexadecimal.
PRNTAX      := $F941 ; Print contents of A and X in hexadecimal.
PRNTX       := $F944 ; Print contents of X in hexadecimal.
PRBLNK      := $F948 ; Print three spaces.
PRBL2       := $F94A ; Print X spaces
PRBL3       := $F94C ; Print the character in A followed by X - 1 spaces.
PCADJ       := $F953 ; Increment the program counter at PCL/H by the value of LENGTH + 1.
TEXT2COPY   := $F962 ; Enable/disable text page 2 shadowing (IIGS).
OLDIRQ      := $FA40 ; Goes to emulation mode interrupt handling routines. (IIGS)
STEP        := $FA43 ; Execute one instruction at address PCL/H, print register contents.
NEWBRK      := $FA47 ; New 6502 break handler.
BREAK       := $FA4C ; Old 6502 break handler.
OLDBRK      := $FA59 ; New 65C816 break handler. (IIGS)
RESET       := $FA62 ; Hardware reset handler. Does not return to caller.
PWRUP       := $FAA6 ; Reboot the system. Does not return to caller.
SLOOP       := $FABA ; Disk controller slot search loop.
REGDSP      := $FAD7 ; Print register contents.
RGDSP1      := $FADA ; Calls REGDSP, then outputs a carriage return.
PREAD       := $FB1E ; Read game paddle X, returning its value in Y.
PREAD4      := $FB21 ; Verify that game paddle X is in timeout mode, then call PREAD.
INIT        := $FB2F ; Initialize the text screen, page 1.
SETTXT      := $FB39 ; Set the screen for full text window, but don't force page 1.
SETGR       := $FB40 ; Set lo-res graphics mode.
SETWND      := $FB4B ; Set text window per WNDLFT, WNDWDTH, WNDTOP, WNDBTM.
SETWND2     := $FB51 ; Set text window width to WNDWDTH, bottom row to WNDBTM.
TABV        := $FB5B ; Perform a vertical tab.
APPLEII     := $FB60 ; Clear text screen and display Apple II boot message.
SETPWRC     := $FB6F ; Calculate power-on byte for the reset vector, return it in A.
VIDWAIT     := $FB78 ; Calls KBDWAIT if Control-S is pressed, else output char in A.
KBDWAIT     := $FB88 ; Wait for keypress, then call VIDOUT to display it.
BASCALC     := $FBC1 ; Calculate base address of text line for next text char.
BELL1       := $FBDD ; Sends bell character to output.
BELL1_2     := $FBE2 ; Ring bell for 1/10 second.
BELL2       := $FBE4 ; Toggle speaker at 1kHz for Y clicks.
STORADV     := $FBF0 ; Output character in A and advance the cursor position.
ADVANCE     := $FBF4 ; Advance the cursor position.
VIDOUT      := $FBFD ; Pass printable chars to STORADV, and handle special chars.
BS          := $FC10 ; Move cursor backward one character.
UP          := $FC1A ; Move cursor up one line.
VTAB        := $FC22 ; Vertical tab.
VTABZ       := $FC24 ; Same as VTAB, but ignoring cursor vertical position.
CLREOP      := $FC42 ; Clear text screen from cursor position to bottom right corner.
HOME        := $FC58 ; Clear text screen.
CR          := $FC62 ; Perform carriage return.
LF          := $FC66 ; Perform line feed.
SCROLL      := $FC70 ; Scroll the text window up one row.
CLREOL      := $FC9C ; Clear the text window from the cursor to the end of the line.
CLREOLZ     := $FC9E ; Clear the text window from column Y to the end of the line.
WAIT        := $FCA8 ; Execute a delay.
NXTA4       := $FCB4 ; Increment the pointer at A1, then call NXTA1.
NXTA1       := $FCBA ; If A1 < A2, increment A1 and clear Carry, else set Carry.
HEADR       := $FCC9 ; Write leader tone to cassette recorder (II, II+, IIe only).
RDKEY       := $FD0C ; Display blinking cursor, read keypress, and call FD10.
FD10        := $FD10 ; Historical entry point. Falls through to RDKEY1.
RDKEY1      := $FD18 ; Indirect jump to input routine at KSW. Normally KEYIN.
KEYIN       := $FD1B ; Display cursor, wait for keypress, and return it in A.
RDCHAR      := $FD35 ; Wait for keypress by calling routine at KSW.
GETLNZ      := $FD67 ; Output a carriage return and call GETLN.
GETLN       := $FD6A ; Output prompt character PROMPT and read line of input.
GETLN0      := $FD6C ; Like GETLN, but use prompt character in A.
GETLN1      := $FD6F ; Like GETLN, but do not display a prompt.
CROUT1      := $FD8B ; Clear to end of line in text window, then output carriage return.
CROUT       := $FD8E ; Output a carriage return.
PRA1        := $FD92 ; Output carriage return followed by contents of A1 in hex and a dash.
PRYX3       := $FD99 ; Output Y and X in hexadecimal, followed by a dash.
XAM8        := $FDA3 ; Output 8 memory locations in hex, starting at A1. Call with Y=0.
XAM         := $FDB3 ; Output in hex the memory locations from A1 to A2. Call with Y=0.
PRBYTE      := $FDDA ; Output A in hexadecimal.
PRHEX       := $FDE3 ; Output the lower nibble of A in hexadecimal.
COUT        := $FDED ; Indirect jump to output routine at CSW. Normally COUT1.
COUT1       := $FDF0 ; Output the character in A and advance the cursor position.
COUTZ       := $FDF6 ; Same as COUT1, but ignores INVFLG.
IDROUTINE   := $FE1F ; Return system identification information. (IIGS)
MOVE        := $FE2C ; Copy memory in range A1-A2 to memory starting at A4.
VERIFY      := $FE36 ; Compoare memory in range A1-A2 to memory starting at A4.
LIST        := $FE5E ; Disassemble and print 20 instructions starting at A1.
SETINV      := $FE80 ; Turn on inverse text.
SETNORM     := $FE84 ; Turn on normal text.
SETIFLG     := $FE86 ; Set the inverse flag from Y.
SETKBD      := $FE89 ; Set the input hook at KSW to point to the keyboard input routine.
INPORT      := $FE8B ; Set the input hook at KSW to point to ROM input routine for slot A.
SETVID      := $FE93 ; Set the output hook at CSW to point to the screen output routine.
OUTPORT     := $FE95 ; Set the output hook at CSW to point to ROM output routine for slot A.
GO          := $FEB6 ; Restore registers and begin execution at A1.
REGZ        := $FEBF ; Display contents of registers.
WRITE       := $FECD ; Write to cassette tape (II, II+, IIe only).
READ        := $FEFD ; Read from cassette tape (II, II+, IIe only).
PRERR       := $FF2D ; Output "ERR" and call BELL.
BELL        := $FF3A ; Ring the bell without outputting a control character.
RESTORE     := $FF3F ; Restore 6502 registers.
SAVE        := $FF4A ; Save 6502 registers.
IORTS       := $FF58 ; Known RTS instruction.
OLDRST      := $FF59 ; Old monitor entry point. Does not return to caller.
MON         := $FF65 ; Standard monitor entry point, with beep. Does not return to caller.
MONZ        := $FF69 ; Standard monitory entry point. Does not return to caller.
MONZ2       := $FF6C ; Standard monitor entry point. Does not return to caller. (IIGS)
MONZ4       := $FF70 ; Standard monitor entry point. Does not return to caller. (IIGS)
DIG         := $FF8A ; Shifts hex digit from A into A2, then call NXTCHR.
GETNUM      := $FFA7 ; Shift consecutive hex digits from input buffer into A2.
NXTCHR      := $FFAD ; Read hex character from input buffer, then call DIG.
TOSUB       := $FFBE ; Monitor command dispatcher.
ZMODE       := $FFC7 ; Zero the Monitor mode byte at MONMODE.
CHRTBL      := $FFCC ; Monitor command character table.
SUBTL       := $FFE3 ; Monitor command subroutine table.

MAINID      := $FBB3 ; System main ID byte
SUBID1      := $FBC0 ; System sub-ID #1
SUBID2      := $FBBF ; System sub-ID #2




;;; KBD             := $C000 ; (R)  Read keyboard
STORE80OFF      := $C000 ; (W)
;;;CLR80COL        := $C000 ; (W)
STORE80ON       := $C001 ; (W)
;;;SET80COL        := $C001 ; (W)
RDMAINRAM       := $C002 ; (W)
RDCARDRAM       := $C003 ; (W)
WRMAINRAM       := $C004 ; (W)
WRCARDRAM       := $C005 ; (W)
SETSLOTCXROM    := $C006 ; (W)
SETINTCXROM     := $C007 ; (W)
SETSTDZP        := $C008 ; (W)
SETALTZP        := $C009 ; (W)
SETINTC3ROM     := $C00A ; (W)
SETSLOTC3ROM    := $C00B ; (W)
CLR80VID        := $C00C ; (W)
SET80VID        := $C00D ; (W)
CLRALTCHAR      := $C00E ; (W)
SETALTCHAR      := $C00F ; (W)
KBDSTRB         := $C010 ; (R7/W)
RDLCBNK2        := $C011 ; (R7)
RDLCRAM         := $C012 ; (R7)
RDRAMRD         := $C013 ; (R7)
RDRAMWRT        := $C014 ; (R7)
RDCXROM         := $C015 ; (R7)
RDALTZP         := $C016 ; (R7)
RDC3ROM         := $C017 ; (R7)
RD80STORE       := $C018 ; (R7)
;;;RD80COL         := $C018 ; (R7)
VBLINT          := $C019 ; (R7)
RDTEXT          := $C01A ; (R7)
RDMIX           := $C01B ; (R7)
RDPAGE2         := $C01C ; (R7)
RDHIRES         := $C01D ; (R7)
ALTCHARSET      := $C01E ; (R7)
RD80VID         := $C01F ; (R7)
TAPEOUT         := $C020 ; (R)
MONOCOLOR       := $C021 ; (W7)
TBCOLOR         := $C022 ; (R/W)
VGCINT          := $C023 ; (R/W)
MOUSEDATA       := $C024 ; (R)
KEYMODREG       := $C025 ; (R)
DATAREG         := $C026 ; (R/W)
KMSTATUS        := $C027 ; (R)
ROMBANK         := $C028 ; (W)
NEWVIDEO        := $C029 ; (R/W)
LANGSEL         := $C02B ; (R/W)
CHARROM         := $C02C ; (R/W)
SLTROMSEL       := $C02D ; (R/W)
VERTCNT         := $C02E ; (R)
HORIZCNT        := $C02F ; (R)
SPKR            := $C030 ; (R)
DISKREG         := $C031 ; (R/W)
SCANINT         := $C032 ; (R/W)
CLOCKDATA       := $C033 ; (R/W)
CLOCKCTL        := $C034 ; (R/W)
SHADOW          := $C035 ; (R/W)
CYAREG          := $C036 ; (R/W)
DMAREG          := $C037 ; (W)
SCCBREG         := $C038 ; (W)
SCCAREG         := $C039 ; (W)
SCCBDATA        := $C03A ; (R/W)
SCCADATA        := $C03B ; (R/W)
SOUNDCTL        := $C03C ; (R/W)
SOUNDDATA       := $C03D ; (R/W)
SOUNDADRL       := $C03E ; (R/W)
SOUNDADRH       := $C03F ; (R/W)
STROBE          := $C040 ; (R/W)
;;;RDXYMSK         := $C040 ; (R7)
RDVBLMSK        := $C041 ; (R7)
;;;INTEN           := $C041 ; (R/W)
RDX0EDGE        := $C042 ; (R7)
RDY0EDGE        := $C043 ; (R7)
MMDELTAX        := $C044 ; (R)
MMDELTAY        := $C045 ; (R)
DIAGTYPE        := $C046 ; (W7)
INTFLAG         := $C047 ; (R)
CLRVBLINT       := $C048 ; (W)
CLRXYINT        := $C049 ; (W)
RSTXY           := $C04A ; (R)
EMUBYTE         := $C04F ; (R/W)
TXTCLR          := $C050 ; (R/W)
TXTSET          := $C051 ; (R/W)
MIXCLR          := $C052 ; (R/W)
MIXSET          := $C053 ; (R/W)
TXTPAGE1        := $C054 ; (R/W)
TXTPAGE2        := $C055 ; (R/W)
LORES           := $C056 ; (R/W)
HIRES           := $C057 ; (R/W)
CLRAN0          := $C058 ; (R/W)
;;;DISXY           := $C058 ; (R/W)
SETAN0          := $C059 ; (R/W)
;;;ENBXY           := $C059 ; (R/W)
CLRAN1          := $C05A ; (R/W)
;;;DISVBL          := $C05A ; (R/W)
SETAN1          := $C05B ; (R/W)
;;;ENVBL           := $C05B ; (R/W)
CLRAN2          := $C05C ; (R/W)
;;;RX0EDGE         := $C05C ; (R/W)
SETAN2          := $C05D ; (R/W)
;;;FX0EDGE         := $C05D ; (R/W)
;;;CLRAN3          := $C05E ; (R/W)
;;;RY0EDGE         := $C05E ; (R/W)
DHIRESON        := $C05E ; (R/W)
;;;SETAN3          := $C05F ; (R/W)
;;;FY0EDGE         := $C05F ; (R/W)
DHIRESOFF       := $C05F ; (R/W)
;;;TAPEIN          := $C060 ; (R7)
RD80SW          := $C060 ; (R7)
;;;RDBTN3          := $C060 ; (R7)
RDBTN0          := $C061 ; (R7)
RDBTN1          := $C062 ; (R7)
RDBTN2          := $C063 ; (R7)
;;;RD63            := $C063 ; (R7)
RDPADDL0        := $C064 ; (R7)
RDPADDL1        := $C065 ; (R7)
RDPADDL2        := $C066 ; (R7)
;;;RDMOUX1         := $C066 ; (R7)
RDPADDL3        := $C067 ; (R7)
;;;RDMOUY1         := $C067 ; (R7)
STATEREG        := $C068 ; (R)
TESTREG         := $C06D ; (R)
CLRTM           := $C06E ; (W)
ENTM            := $C06F ; (W)
PTRIG           := $C070 ; (R/W)
BANKSEL         := $C073 ; (W)
CPUSPEED        := $C074 ; (W)
BLOSSOM         := $C077 ; (W)
IOUDISON        := $C07E ; (W)
;;;RDIOUDIS        := $C07E ; (R)
;;;IOUDISOFF       := $C07F ; (W)
RDDHIRES        := $C07F ; (R)
RDLCRAMB2       := $C080 ; (R)
WRLCRAMB2       := $C081 ; (R/RR)
;;;ROMIN           := $C081 ; (R/RR)
RDROMLCB2       := $C082 ; (R)
RWLCRAMB2       := $C083 ; (R/RR)
RDLCRAMB1       := $C088 ; (R)
WRLCRAMB1       := $C089 ; (R/RR)
RDROMLCB1       := $C08A ; (R)
RWLCRAMB1       := $C08B ; (R/RR)
;;;LCBANK1         := $C08B ; (R/RR)
DATAREG1        := $C098 ; (R/W)
STATUS1         := $C099 ; (R/W)
COMMAND1        := $C09A ; (W)
CONTROL1        := $C09B ; (W)
DATAREG2        := $C0A8 ; (R/W)
STATUS2         := $C0A9 ; (R/W)
COMMAND2        := $C0AA ; (W)
CONTROL2        := $C0AB ; (W)
ADDRL           := $C0C0 ; (W)
ADDRM           := $C0C1 ; (W)
ADDRH           := $C0C2 ; (W)
DATA            := $C0C3 ; (R/W)
CA0L            := $C0E0 ; (R/W)
CA0H            := $C0E1 ; (R/W)
CA1L            := $C0E2 ; (R/W)
CA1H            := $C0E3 ; (R/W)
CA2L            := $C0E4 ; (R/W)
CA2H            := $C0E5 ; (R/W)
CA3L            := $C0E6 ; (R/W)
;;;LSTRBL          := $C0E6 ; (R/W)
CA3H            := $C0E7 ; (R/W)
;;;LSTRBH          := $C0E7 ; (R/W)
ENABLEL         := $C0E8 ; (R/W)
ENABLEH         := $C0E9 ; (R/W)
DRV0EN          := $C0EA ; (R/W)
DRV1EN          := $C0EB ; (R/W)
Q6L             := $C0EC ; (R/W)
Q6H             := $C0ED ; (R/W)
Q7L             := $C0EE ; (R/W)
Q7H             := $C0EF ; (R/W)
CLRROM          := $CFFF ; (W)

;;;SLOT1SW         := $C010
;;;SLOT2SW         := $C020
;;;SLOT3SW         := $C030
;;;SLOT4SW         := $C040
;;;SLOT5SW         := $C050
;;;SLOT6SW         := $C060
;;;SLOT7SW         := $C080


MLI             := $BF00        ; MLI entry point

;;; ProDOS global page locations
CLKENTRY        := $BF06 ; Clock driver entry point
DEVADR0         := $BF10 ; Device driver address table
DEVNUM          := $BF30 ; Last used device number
DEVCNT          := $BF31 ; Number of online devices minus 1
DEVLST          := $BF32 ; Device list
MEMTABL         := $BF58 ; Memory allocation bitmap
GLBUFF          := $BF70 ; File buffer address table
DATELO          := $BF90 ; Low byte of date
DATEHI          := $BF91 ; High byte of date
TIMELO          := $BF92 ; Low byte of time
TIMEHI          := $BF93 ; High byte of time
LEVEL           := $BF94 ; Current file level
BUBIT           := $BF95 ; Backup-needed bit disable
MACHID          := $BF98 ; Machine ID
SLTBYT          := $BF99 ; Peripheral ROM presence mask
PFIXPTR         := $BF9A ; If not 0, a prefix is active
MLIACTV         := $BF9B ; If not 0, a MLI call is in progress
IVERSION        := $BFFD ; Version of current SYS program
KVERSION        := $BFFF ; Version of ProDOS kernel

