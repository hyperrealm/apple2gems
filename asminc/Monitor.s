 .scope Monitor

PLOT        := $F800 ; Plot lo-res point at col Y, row A.
PLOT1       := $F80E ; Plot lo-res point at col Y, row GBAS.
HLINE       := $F819 ; Plot lo-res horizontal line at row A, cols Y - H2.
VLINE       := $F828 ; Plot lo-res vertical line at col Y, rows A - V2.
CLRSCR      := $F832 ; Clear the entire lo-res screen.
CLRTOP      := $F836 ; Clear the top 40 rows of the lo-res screen.
CLRSC2      := $F838 ; Clear the lo-res screen from the top to row Y.
CLRSC3      := $F83C ; Clear the lo-res screen from top left to row V2, col Y.
GBASCALC    := $F847 ; Calculate base address for lo-res point where A contains row / 2.
NXTCOL      := $F85F ; Add 3 to current lo-res color that was set by SETCOL.
SETCOL      := $F864 ; Set the lo-res color to A.
SCRN        := $F871 ; Return in A the color code for lo-res point at row A, col Y.
INSDS2      := $F88E ; Compute length of 65(C)02 instruction in A. Stores length - 1 at LENGTH.
GET816LEN   := $F890 ; Compute length of 65C812 instruction in A. Stores length - 1 at LENGTH. (IIGS)
INSTDSP     := $F8D0 ; Display disassembled instruction at address in PCL/H.
PRNTYX      := $F940 ; Print contents of Y and X in hexadecimal.
PRNTAX      := $F941 ; Print contents of A and X in hexadecimal.
PRNTX       := $F944 ; Print contents of X in hexadecimal.
PRBLNK      := $F948 ; Print three spaces.
PRBL2       := $F94A ; Print X spaces
PRBL3       := $F94C ; Print the character in A followed by X - 1 spaces.
PCADJ       := $F953 ; Increment the program counter at PCL/H by the value of LENGTH + 1.
TEXT2COPY   := $F962 ; Enable/disable text page 2 shadowing (IIGS).
OLDIRQ      := $FA40 ; Goes to emulation mode interrupt handling routines. (IIGS)
STEP        := $FA43 ; Execute one instruction at address PCL/H, print register contents.
NEWBRK      := $FA47 ; New 6502 break handler.
BREAK       := $FA4C ; Old 6502 break handler.
OLDBRK      := $FA59 ; New 65C816 break handler. (IIGS)
RESET       := $FA62 ; Hardware reset handler. Does not return to caller.
PWRUP       := $FAA6 ; Reboot the system. Does not return to caller.
SLOOP       := $FABA ; Disk controller slot search loop.
REGDSP      := $FAD7 ; Print register contents.
RGDSP1      := $FADA ; Calls REGDSP, then outputs a carriage return.
PREAD       := $FB1E ; Read game paddle X, returning its value in Y.
PREAD4      := $FB21 ; Verify that game paddle X is in timeout mode, then call PREAD.
INIT        := $FB2F ; Initialize the text screen, page 1.
SETTXT      := $FB39 ; Set the screen for full text window, but don't force page 1.
SETGR       := $FB40 ; Set lo-res graphics mode.
SETWND      := $FB4B ; Set text window per WNDLFT, WNDWDTH, WNDTOP, WNDBTM.
SETWND2     := $FB51 ; Set text window width to WNDWDTH, bottom row to WNDBTM.
TABV        := $FB5B ; Perform a vertical tab.
APPLEII     := $FB60 ; Clear text screen and display Apple II boot message.
SETPWRC     := $FB6F ; Calculate power-on byte for the reset vector, return it in A.
VIDWAIT     := $FB78 ; Calls KBDWAIT if Control-S is pressed, else output char in A.
KBDWAIT     := $FB88 ; Wait for keypress, then call VIDOUT to display it.
BASCALC     := $FBC1 ; Calculate base address of text line for next text char.
BELL1       := $FBDD ; Sends bell character to output.
BELL1_2     := $FBE2 ; Ring bell for 1/10 second.
BELL2       := $FBE4 ; Toggle speaker at 1kHz for Y clicks.
STORADV     := $FBF0 ; Output character in A and advance the cursor position.
ADVANCE     := $FBF4 ; Advance the cursor position.
VIDOUT      := $FBFD ; Pass printable chars to STORADV, and handle special chars.
BS          := $FC10 ; Move cursor backward one character.
UP          := $FC1A ; Move cursor up one line.
VTAB        := $FC22 ; Vertical tab.
VTABZ       := $FC24 ; Same as VTAB, but ignoring cursor vertical position.
CLREOP      := $FC42 ; Clear text screen from cursor position to bottom right corner.
HOME        := $FC58 ; Clear text screen.
CR          := $FC62 ; Perform carriage return.
LF          := $FC66 ; Perform line feed.
SCROLL      := $FC70 ; Scroll the text window up one row.
CLREOL      := $FC9C ; Clear the text window from the cursor to the end of the line.
CLREOLZ     := $FC9E ; Clear the text window from column Y to the end of the line.
WAIT        := $FCA8 ; Execute a delay.
NXTA4       := $FCB4 ; Increment the pointer at A1, then call NXTA1.
NXTA1       := $FCBA ; If A1 < A2, increment A1 and clear Carry, else set Carry.
HEADR       := $FCC9 ; Write leader tone to cassette recorder (II, II+, IIe only).
RDKEY       := $FD0C ; Display blinking cursor, read keypress, and call FD10.
FD10        := $FD10 ; Historical entry point. Falls through to RDKEY1.
RDKEY1      := $FD18 ; Indirect jump to input routine at KSW. Normally KEYIN.
KEYIN       := $FD1B ; Display cursor, wait for keypress, and return it in A.
RDCHAR      := $FD35 ; Wait for keypress by calling routine at KSW.
GETLNZ      := $FD67 ; Output a carriage return and call GETLN.
GETLN       := $FD6A ; Output prompt character PROMPT and read line of input.
GETLN0      := $FD6C ; Like GETLN, but use prompt character in A.
GETLN1      := $FD6F ; Like GETLN, but do not display a prompt.
CROUT1      := $FD8B ; Clear to end of line in text window, then output carriage return.
CROUT       := $FD8E ; Output a carriage return.
PRA1        := $FD92 ; Output carriage return followed by contents of A1 in hex and a dash.
PRYX3       := $FD99 ; Output Y and X in hexadecimal, followed by a dash.
XAM8        := $FDA3 ; Output 8 memory locations in hex, starting at A1. Call with Y=0.
XAM         := $FDB3 ; Output in hex the memory locations from A1 to A2. Call with Y=0.
PRBYTE      := $FDDA ; Output A in hexadecimal.
PRHEX       := $FDE3 ; Output the lower nibble of A in hexadecimal.
COUT        := $FDED ; Indirect jump to output routine at CSW. Normally COUT1.
COUT1       := $FDF0 ; Output the character in A and advance the cursor position.
COUTZ       := $FDF6 ; Same as COUT1, but ignores INVFLG.
IDROUTINE   := $FE1F ; Return system identification information. (IIGS)
MOVE        := $FE2C ; Copy memory in range A1-A2 to memory starting at A4.
VERIFY      := $FE36 ; Compoare memory in range A1-A2 to memory starting at A4.
LIST        := $FE5E ; Disassemble and print 20 instructions starting at A1.
SETINV      := $FE80 ; Turn on inverse text.
SETNORM     := $FE84 ; Turn on normal text.
SETIFLG     := $FE86 ; Set the inverse flag from Y.
SETKBD      := $FE89 ; Set the input hook at KSW to point to the keyboard input routine.
INPORT      := $FE8B ; Set the input hook at KSW to point to ROM input routine for slot A.
SETVID      := $FE93 ; Set the output hook at CSW to point to the screen output routine.
OUTPORT     := $FE95 ; Set the output hook at CSW to point to ROM output routine for slot A.
GO          := $FEB6 ; Restore registers and begin execution at A1.
REGZ        := $FEBF ; Display contents of registers.
WRITE       := $FECD ; Write to cassette tape (II, II+, IIe only).
READ        := $FEFD ; Read from cassette tape (II, II+, IIe only).
PRERR       := $FF2D ; Output "ERR" and call BELL.
BELL        := $FF3A ; Ring the bell without outputting a control character.
RESTORE     := $FF3F ; Restore 6502 registers.
SAVE        := $FF4A ; Save 6502 registers.
IORTS       := $FF58 ; Known RTS instruction.
OLDRST      := $FF59 ; Old monitor entry point. Does not return to caller.
MON         := $FF65 ; Standard monitor entry point, with beep. Does not return to caller.
MONZ        := $FF69 ; Standard monitory entry point. Does not return to caller.
MONZ2       := $FF6C ; Standard monitor entry point. Does not return to caller. (IIGS)
MONZ4       := $FF70 ; Standard monitor entry point. Does not return to caller. (IIGS)
DIG         := $FF8A ; Shifts hex digit from A into A2, then call NXTCHR.
GETNUM      := $FFA7 ; Shift consecutive hex digits from input buffer into A2.
NXTCHR      := $FFAD ; Read hex character from input buffer, then call DIG.
TOSUB       := $FFBE ; Monitor command dispatcher.
ZMODE       := $FFC7 ; Zero the Monitor mode byte at MONMODE.
CHRTBL      := $FFCC ; Monitor command character table.
SUBTL       := $FFE3 ; Monitor command subroutine table.

.endscope
